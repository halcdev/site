<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Wave Animation with Vapi AI Assistant</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; /* Prevent scrollbars */
        }
        canvas { 
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        /* Force the Vapi button to be a perfect circle and center it */
        .vapi-btn {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            width: 120px !important;
            height: 120px !important;
            border-radius: 50% !important;
            margin: 0 !important;
            z-index: 2 !important; /* Ensure button is above the canvas */
        }
    </style>
</head>
<body>
    <!-- Three.js Script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = null; // Make scene background transparent
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            alpha: true,  // Enable transparency
            antialias: true, // Make edges smoother
            precision: 'highp' // Use high precision rendering
        });
        
        // Set pixel ratio for high DPI displays
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // Set clear color to transparent
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Create ribbon with increased resolution
        let ribbon = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 1, 300, 3), // Increased width to 30 units
            new THREE.MeshStandardMaterial({ 
                color: '#D31CFF', // Vibrant purple
                side: THREE.DoubleSide,
                flatShading: false, // Enable smooth shading
                roughness: 0.5,     // Add some material quality
                metalness: 0.2      // Add slight metallic effect
            })
        );

        scene.add(ribbon);
        ribbon.rotation.x += Math.PI * -.5;
        ribbon.position.y = 0; // Center vertically

        // Set camera position for better framing
        camera.position.set(0, 4, 8); // Moved back and up slightly
        camera.lookAt(0, 0, 0);

        // Add automatic ribbon width adjustment
        function adjustRibbonToScreen() {
            // Calculate the visible width at the ribbon's z-position
            const distance = Math.abs(camera.position.z - ribbon.position.z);
            const vFov = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFov / 2) * distance;
            const visibleWidth = visibleHeight * camera.aspect;
            
            // Add more padding to ensure it extends past the edges
            ribbon.scale.x = (visibleWidth / 30) * 1.5; // Increased from 1.2 to 1.5
        }

        // Function to ensure proper sizing
        function ensureProperSize() {
            // Update renderer size to match current dimensions
            const width = window.innerWidth || document.documentElement.clientWidth;
            const height = window.innerHeight || document.documentElement.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            adjustRibbonToScreen();
        }

        // Modify onWindowResize to use the new function
        function onWindowResize() {
            ensureProperSize();
        }

        // Add resize observer for iframe support
        const resizeObserver = new ResizeObserver(entries => {
            for (const entry of entries) {
                if (entry.target === document.body) {
                    ensureProperSize();
                }
            }
        });
        resizeObserver.observe(document.body);

        // Initial adjustment with delay to ensure proper iframe sizing
        setTimeout(() => {
            ensureProperSize();
        }, 100);

        // Also check size periodically for the first few seconds
        const checkInterval = setInterval(() => {
            ensureProperSize();
        }, 500);

        // Stop checking after 5 seconds
        setTimeout(() => {
            clearInterval(checkInterval);
        }, 5000);

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);

        // Add message listener for iframe communication
        window.addEventListener('message', (event) => {
            if (event.data === 'checkSize') {
                ensureProperSize();
            }
        });

        // Add speed control variables
        let targetSpeedMultiplier = 1;
        let currentSpeedMultiplier = 1;
        const SPEED_UP_FACTOR = 2.0; // Reduced from 2.5 to a more manageable 2.0
        const TRANSITION_DURATION = 0.4; // Transition duration in seconds
        
        // Time tracking to prevent accumulation
        let baseTime = performance.now() / 1000;
        let effectiveTime = 0;

        // Linear interpolation helper
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        let lastTime = performance.now() / 1000;
        let updateRibbon = () => {
            let currentTime = performance.now() / 1000;
            let deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Calculate elapsed time since start
            let rawElapsedTime = currentTime - baseTime;
            
            // Smoothly transition the speed multiplier with better damping
            if (Math.abs(currentSpeedMultiplier - targetSpeedMultiplier) > 0.01) {
                const transitionRate = Math.min(deltaTime / TRANSITION_DURATION, 0.1); // Cap the rate to prevent jumps
                currentSpeedMultiplier = lerp(
                    currentSpeedMultiplier,
                    targetSpeedMultiplier,
                    transitionRate
                );
            } else {
                currentSpeedMultiplier = targetSpeedMultiplier; // Snap to target when close enough
            }
            
            // Update effective time with controlled speed - prevents accumulation
            effectiveTime = rawElapsedTime * currentSpeedMultiplier;
            
            let verts = ribbon.geometry.attributes.position.array;

            for (let i = 0; i < verts.length; i += 3) {
                let vx = verts[i];
                let vy = verts[i + 1];
                // Use effectiveTime instead of accumulating currentTime
                verts[i + 2] = Math.sin(effectiveTime + (vx * 1.1)) * .3;
                verts[i + 2] += Math.sin(effectiveTime + (vx * 2.1)) * .15;
                verts[i + 2] += Math.cos(effectiveTime + (vx + vy * 1.1)) * .3;
            }

            ribbon.geometry.computeVertexNormals();
            ribbon.geometry.attributes.position.needsUpdate = true;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updateRibbon();
            renderer.render(scene, camera);
        }

        animate();
    </script>

    <!-- Vapi AI Assistant Script -->
    <script>
        var vapiInstance = null;
        const assistant = "1e65c9ab-8823-4412-9d0c-dc44f1de486f";
        const apiKey = "c511b347-7f29-4262-aa4d-4c0c44bebca1";

        // Track button state
        let buttonState = 'idle'; // 'idle', 'loading', or 'active'

        // Function to handle button state changes
        function updateButtonState(newState) {
            console.log(`Button state changed from ${buttonState} to ${newState}`);
            buttonState = newState;
            
            // Update wave speed based on button state
            if (newState === 'loading') {
                targetSpeedMultiplier = SPEED_UP_FACTOR; // Speed up during loading
            } else {
                targetSpeedMultiplier = 1; // Normal speed for idle and active
            }
        }

        // Button configuration: circular button with purple shades
        const buttonConfig = {
            position: "bottom-right",
            offset: "0px",
            width: "120px",
            height: "120px",
            idle: {
                color: `#E94FE9`,  // Deep purple for idle state
                type: "round",
                icon: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 473.806 473.806' fill='%23ffffff' stroke='%23ffffff'%3E%3Cg%3E%3Cg%3E%3Cpath d='M374.456,293.506c-9.7-10.1-21.4-15.5-33.8-15.5c-12.3,0-24.1,5.3-34.2,15.4l-31.6,31.5c-2.6-1.4-5.2-2.7-7.7-4 c-3.6-1.8-7-3.5-9.9-5.3c-29.6-18.8-56.5-43.3-82.3-75c-12.5-15.8-20.9-29.1-27-42.6c8.2-7.5,15.8-15.3,23.2-22.8 c2.8-2.8,5.6-5.7,8.4-8.5c21-21,21-48.2,0-69.2l-27.3-27.3c-3.1-3.1-6.3-6.3-9.3-9.5c-6-6.2-12.3-12.6-18.8-18.6 c-9.7-9.6-21.3-14.7-33.5-14.7s-24,5.1-34,14.7c-0.1,0.1-0.1,0.1-0.2,0.2l-34,34.3c-12.8,12.8-20.1,28.4-21.7,46.5 c-2.4,29.2,6.2,56.4,12.8,74.2c16.2,43.7,40.4,84.2,76.5,127.6c43.8,52.3,96.5,93.6,156.7,122.7c23,10.9,53.7,23.8,88,26 c2.1,0.1,4.3,0.2,6.3,0.2c23.1,0,42.5-8.3,57.7-24.8c0.1-0.2,0.3-0.3,0.4-0.5c5.2-6.3,11.2-12,17.5-18.1c4.3-4.1,8.7-8.4,13-12.9 c9.9-10.3,15.1-22.3,15.1-34.6c0-12.4-5.3-24.3-15.4-34.3L374.456,293.506z M410.256,398.806 C410.156,398.806,410.156,398.906,410.256,398.806c-3.9,4.2-7.9,8-12.2,12.2c-6.5,6.2-13.1,12.7-19.3,20 c-10.1,10.8-22,15.9-37.6,15.9c-1.5,0-3.1,0-4.6-0.1c-29.7-1.9-57.3-13.5-78-23.4c-56.6-27.4-106.3-66.3-147.6-115.6 c-34.1-41.1-56.9-79.1-72-119.9c-9.3-24.9-12.7-44.3-11.2-62.6c1-11.7,5.5-21.4,13.8-29.7l34.1-34.1c4.9-4.6,10.1-7.1,15.2-7.1 c6.3,0,11.4,3.8,14.6,7c0.1,0.1,0.2,0.2,0.3,0.3c6.1,5.7,11.9,11.6,18,17.9c3.1,3.2,6.3,6.4,9.5,9.7l27.3,27.3 c10.6,10.6,10.6,20.4,0,31c-2.9,2.9-5.7,5.8-8.6,8.6c-8.4,8.6-16.4,16.6-25.1,24.4c-0.2,0.2-0.4,0.3-0.5,0.5 c-8.6,8.6-7,17-5.2,22.7c0.1,0.3,0.2,0.6,0.3,0.9c7.1,17.2,17.1,33.4,32.3,52.7l0.1,0.1c27.6,34,56.7,60.5,88.8,80.8 c4.1,2.6,8.3,4.7,12.3,6.7c3.6,1.8,7,3.5,9.9,5.3c0.4,0.2,0.8,0.5,1.2,0.7c3.4,1.7,6.6,2.5,9.9,2.5c8.3,0,13.5-5.2,15.2-6.9 l34.2-34.2c3.4-3.4,8.8-7.5,15.1-7.5c6.2,0,11.3,3.9,14.4,7.3c0.1,0.1,0.1,0.1,0.2,0.2l55.1,55.1 C420.456,377.706,420.456,388.206,410.256,398.806z'/%3E%3Cpath d='M256.056,112.706c26.2,4.4,50,16.8,69,35.8s31.3,42.8,35.8,69c1.1,6.6,6.8,11.2,13.3,11.2c0.8,0,1.5-0.1,2.3-0.2 c7.4-1.2,12.3-8.2,11.1-15.6c-5.4-31.7-20.4-60.6-43.3-83.5s-51.8-37.9-83.5-43.3c-7.4-1.2-14.3,3.7-15.6,11 S248.656,111.506,256.056,112.706z'/%3E%3Cpath d='M473.256,209.006c-8.9-52.2-33.5-99.7-71.3-137.5s-85.3-62.4-137.5-71.3c-7.3-1.3-14.2,3.7-15.5,11 c-1.2,7.4,3.7,14.3,11.1,15.6c46.6,7.9,89.1,30,122.9,63.7c33.8,33.8,55.8,76.3,63.7,122.9c1.1,6.6,6.8,11.2,13.3,11.2 c0.8,0,1.5-0.1,2.3-0.2C469.556,223.306,474.556,216.306,473.256,209.006z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E`
            },
            loading: {
                color: `rgb(186,85,211)`, // Lighter purple when connecting
                type: "round",
                icon: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 12a9 9 0 1 1-6.219-8.56'%3E%3C/path%3E%3C/svg%3E`
            },
            active: {
                color: `rgb(169, 0, 187)`, // Soft purple when active
                type: "round",
                icon: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91'%3E%3C/path%3E%3Cline x1='23' y1='1' x2='1' y2='23'%3E%3C/line%3E%3C/svg%3E`
            }
        };

        (function (d, t) {
            var g = d.createElement(t),
                s = d.getElementsByTagName(t)[0];
            g.src = "https://cdn.jsdelivr.net/gh/VapiAI/html-script-tag@latest/dist/assets/index.js";
            g.defer = true;
            g.async = true;
            s.parentNode.insertBefore(g, s);
            g.onload = function () {
                vapiInstance = window.vapiSDK.run({
                    apiKey: apiKey,
                    assistant: assistant,
                    config: buttonConfig
                });

                // Listen to all state change events
                vapiInstance.on('state-change', (state) => {
                    console.log('State changed:', state);
                    if (state === 'connecting' || state === 'reconnecting') {
                        updateButtonState('loading');
                    } else if (state === 'connected') {
                        updateButtonState('active');
                    } else if (state === 'disconnected' || state === 'idle') {
                        updateButtonState('idle');
                    }
                });

                // Also listen to button clicks directly
                document.addEventListener('click', (e) => {
                    // Check if the click was on the Vapi button
                    if (e.target.closest('.vapi-btn')) {
                        console.log('Button clicked');
                        // If we're in idle state, this click should transition to loading
                        if (buttonState === 'idle') {
                            updateButtonState('loading');
                        }
                    }
                }, true);

                // Backup events in case state-change doesn't work reliably
                vapiInstance.on('call-start', () => { 
                    console.log('Call has started');
                    updateButtonState('active');
                });

                vapiInstance.on('call-end', () => { 
                    console.log('Call has stopped');
                    updateButtonState('idle');
                });

                // Additional listeners for debugging
                vapiInstance.on('speech-start', () => { console.log('Speech has started'); });
                vapiInstance.on('speech-end', () => { console.log('Speech has ended'); });
                vapiInstance.on('volume-level', (volume) => { console.log(`Volume: ${volume}`); });
                vapiInstance.on('message', (message) => { console.log('Message:', message); });
                vapiInstance.on('error', (e) => { console.error('Error:', e); });
            };
        })(document, "script");
    </script>
</body>
</html> 